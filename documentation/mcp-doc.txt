TITLE: MCP Connection Lifecycle Diagram
DESCRIPTION: A sequence diagram illustrating the initialization process of an MCP connection between client and server, including initialize request/response and initialized notification.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/docs/concepts/architecture.mdx#2025-04-23_snippet_7

LANGUAGE: mermaid
CODE:
```
sequenceDiagram
    participant Client
    participant Server

    Client->>Server: initialize request
    Server->>Client: initialize response
    Client->>Server: initialized notification

    Note over Client,Server: Connection ready for use
```

----------------------------------------

TITLE: Defining JSON-RPC Request Message Structure in TypeScript
DESCRIPTION: TypeScript interface defining the structure of JSON-RPC 2.0 request messages. Requests must include a unique ID (string or number), method name, and optional parameters object.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/specification/2025-03-26/basic/index.mdx#2025-04-23_snippet_0

LANGUAGE: typescript
CODE:
```
{
  jsonrpc: "2.0";
  id: string | number;
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

----------------------------------------

TITLE: Defining JSON-RPC Request Structure in TypeScript
DESCRIPTION: This snippet defines the structure of a JSON-RPC 2.0 request message used in the Model Context Protocol. It specifies the required fields and their types, including the JSON-RPC version, request ID, method, and optional parameters.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/specification/draft/basic/index.mdx#2025-04-23_snippet_0

LANGUAGE: typescript
CODE:
```
{
  jsonrpc: "2.0";
  id: string | number;
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

----------------------------------------

TITLE: Processing User Queries with Anthropic and MCP (TypeScript)
DESCRIPTION: Takes a user `query` string, sends it to the Anthropic API (Claude 3.5 Sonnet) along with available tools. It processes the API response, extracting text content and handling tool use requests. For tool use, it calls the corresponding tool via the MCP client, includes the tool result in the conversation, and potentially makes another API call with the updated messages. Returns the combined text response.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/quickstart/client.mdx#_snippet_19

LANGUAGE: typescript
CODE:
```
async processQuery(query: string) {
  const messages: MessageParam[] = [
    {
      role: "user",
      content: query,
    },
  ];

  const response = await this.anthropic.messages.create({
    model: "claude-3-5-sonnet-20241022",
    max_tokens: 1000,
    messages,
    tools: this.tools,
  });

  const finalText = [];
  const toolResults = [];

  for (const content of response.content) {
    if (content.type === "text") {
      finalText.push(content.text);
    } else if (content.type === "tool_use") {
      const toolName = content.name;
      const toolArgs = content.input as { [x: string]: unknown } | undefined;

      const result = await this.mcp.callTool({
        name: toolName,
        arguments: toolArgs,
      });
      toolResults.push(result);
      finalText.push(
        `[Calling tool ${toolName} with args ${JSON.stringify(toolArgs)}]`
      );

      messages.push({
        role: "user",
        content: result.content as string,
      });

      const response = await this.anthropic.messages.create({
        model: "claude-3-5-sonnet-20241022",
        max_tokens: 1000,
        messages,
      });

      finalText.push(
        response.content[0].type === "text" ? response.content[0].text : ""
      );
    }
  }

  return finalText.join("\n");
}
```

----------------------------------------

TITLE: Processing User Queries with Anthropic and Tool Calls (Kotlin)
DESCRIPTION: Initializes Anthropic message parameters and defines a suspend function to process user queries. It sends the query to the Anthropic API, handles text responses, and processes tool use requests by calling the specified tool via the MCP client and sending the result back to the API for further processing.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/quickstart/client.mdx#_snippet_48

LANGUAGE: kotlin
CODE:
```
private val messageParamsBuilder: MessageCreateParams.Builder = MessageCreateParams.builder()
    .model(Model.CLAUDE_3_5_SONNET_20241022)
    .maxTokens(1024)

suspend fun processQuery(query: String): String {
    val messages = mutableListOf(
        MessageParam.builder()
            .role(MessageParam.Role.USER)
            .content(query)
            .build()
    )

    val response = anthropic.messages().create(
        messageParamsBuilder
            .messages(messages)
            .tools(tools)
            .build()
    )

    val finalText = mutableListOf<String>()
    response.content().forEach { content ->
        when {
            content.isText() -> finalText.add(content.text().getOrNull()?.text() ?: "")

            content.isToolUse() -> {
                val toolName = content.toolUse().get().name()
                val toolArgs =
                    content.toolUse().get()._input().convert(object : TypeReference<Map<String, JsonValue>>() {})

                val result = mcp.callTool(
                    name = toolName,
                    arguments = toolArgs ?: emptyMap()
                )
                finalText.add("[Calling tool $toolName with args $toolArgs]")

                messages.add(
                    MessageParam.builder()
                        .role(MessageParam.Role.USER)
                        .content(
                            """
                                \"type\": \"tool_result\",
                                \"tool_name\": $toolName,
                                \"result\": ${result?.content?.joinToString("\\n") { (it as TextContent).text ?: "" }}
                            """.trimIndent()
                        )
                        .build()
                )

                val aiResponse = anthropic.messages().create(
                    messageParamsBuilder
                        .messages(messages)
                        .build()
                )

                finalText.add(aiResponse.content().first().text().getOrNull()?.text() ?: "")
            }
        }
    }

    return finalText.joinToString("\n", prefix = "", postfix = "")
}
```

----------------------------------------

TITLE: Sending Initialize Request in MCP
DESCRIPTION: JSON-RPC request for initializing the Model Context Protocol. It includes the protocol version, client capabilities, and client information. This request must be the first interaction between client and server.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/specification/2025-03-26/basic/lifecycle.mdx#2025-04-23_snippet_1

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "protocolVersion": "2024-11-05",
    "capabilities": {
      "roots": {
        "listChanged": true
      },
      "sampling": {}
    },
    "clientInfo": {
      "name": "ExampleClient",
      "version": "1.0.0"
    }
  }
}
```

----------------------------------------

TITLE: Implementing Weather Tools for MCP Server
DESCRIPTION: TypeScript code implementing two MCP tools: 'get-alerts' for retrieving weather alerts for a state, and 'get-forecast' for getting weather forecasts for a specific location.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/quickstart/server.mdx#2025-04-23_snippet_17

LANGUAGE: typescript
CODE:
```
// Register weather tools
server.tool(
  "get-alerts",
  "Get weather alerts for a state",
  {
    state: z.string().length(2).describe("Two-letter state code (e.g. CA, NY)"),
  },
  async ({ state }) => {
    const stateCode = state.toUpperCase();
    const alertsUrl = `${NWS_API_BASE}/alerts?area=${stateCode}`;
    const alertsData = await makeNWSRequest<AlertsResponse>(alertsUrl);

    if (!alertsData) {
      return {
        content: [
          {
            type: "text",
            text: "Failed to retrieve alerts data",
          },
        ],
      };
    }

    const features = alertsData.features || [];
    if (features.length === 0) {
      return {
        content: [
          {
            type: "text",
            text: `No active alerts for ${stateCode}`,
          },
        ],
      };
    }

    const formattedAlerts = features.map(formatAlert);
    const alertsText = `Active alerts for ${stateCode}:\n\n${formattedAlerts.join("\n")}`;

    return {
      content: [
        {
          type: "text",
          text: alertsText,
        },
      ],
    };
  },
);

server.tool(
  "get-forecast",
  "Get weather forecast for a location",
  {
    latitude: z.number().min(-90).max(90).describe("Latitude of the location"),
    longitude: z.number().min(-180).max(180).describe("Longitude of the location"),
  },
  async ({ latitude, longitude }) => {
    // Get grid point data
    const pointsUrl = `${NWS_API_BASE}/points/${latitude.toFixed(4)},${longitude.toFixed(4)}`;
    const pointsData = await makeNWSRequest<PointsResponse>(pointsUrl);

    if (!pointsData) {
      return {
        content: [
          {
            type: "text",
            text: `Failed to retrieve grid point data for coordinates: ${latitude}, ${longitude}. This location may not be supported by the NWS API (only US locations are supported).`,
          },
        ],
      };
    }

    const forecastUrl = pointsData.properties?.forecast;
    if (!forecastUrl) {
      return {
        content: [
          {
            type: "text",
            text: "Failed to get forecast URL from grid point data",
          },
        ],
      };
    }

    // Get forecast data
    const forecastData = await makeNWSRequest<ForecastResponse>(forecastUrl);
    if (!forecastData) {
      return {
        content: [
          {
            type: "text",
            text: "Failed to retrieve forecast data",
          },
        ],
      };
    }

    const periods = forecastData.properties?.periods || [];
    if (periods.length === 0) {
      return {
        content: [
          {
            type: "text",
            text: "No forecast periods available",
          },
        ],
      };
    }

    // Format forecast periods
    const formattedForecast = periods.map((period: ForecastPeriod) =>
      [
        `${period.name || "Unknown"}:`,
        `Temperature: ${period.temperature || "Unknown"}°${period.temperatureUnit || "F"}`,
        `Wind: ${period.windSpeed || "Unknown"} ${period.windDirection || ""}`,
        `${period.shortForecast || "No forecast available"}`,
        "---",
      ].join("\n"),
    );

    const forecastText = `Forecast for ${latitude}, ${longitude}:\n\n${formattedForecast.join("\n")}`;

    return {
      content: [
        {
          type: "text",
          text: forecastText,
        },
      ],
    };
  },
);
```

----------------------------------------

TITLE: Main Entry Point for MCP Client (TypeScript)
DESCRIPTION: This asynchronous function serves as the main entry point for the MCP client application. It checks for command-line arguments, initializes the MCPClient, connects to the specified server path, runs the chat loop, and ensures cleanup before exiting.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/quickstart/client.mdx#_snippet_21

LANGUAGE: TypeScript
CODE:
```
async function main() {
  if (process.argv.length < 3) {
    console.log("Usage: node index.ts <path_to_server_script>");
    return;
  }
  const mcpClient = new MCPClient();
  try {
    await mcpClient.connectToServer(process.argv[2]);
    await mcpClient.chatLoop();
  } finally {
    await mcpClient.cleanup();
    process.exit(0);
  }
}

main();
```

----------------------------------------

TITLE: Defining Response Structure in TypeScript for Model Context Protocol
DESCRIPTION: This snippet outlines the structure of a Response message in the Model Context Protocol. It includes the jsonrpc version, id matching the corresponding request, and either a result or an error object. The error object must contain a code (integer) and a message, with an optional data field.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/specification/2024-11-05/basic/messages.mdx#2025-04-23_snippet_1

LANGUAGE: typescript
CODE:
```
{
  jsonrpc: "2.0";
  id: string | number;
  result?: {
    [key: string]: unknown;
  }
  error?: {
    code: number;
    message: string;
    data?: unknown;
  }
}
```

----------------------------------------

TITLE: JSON-RPC Message Format Definitions
DESCRIPTION: Type definitions for the three JSON-RPC message formats used in MCP: requests, responses, and notifications.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/docs/concepts/transports.mdx#2025-04-23_snippet_0

LANGUAGE: typescript
CODE:
```
{
  jsonrpc: "2.0",
  id: number | string,
  method: string,
  params?: object
}
```

LANGUAGE: typescript
CODE:
```
{
  jsonrpc: "2.0",
  id: number | string,
  result?: object,
  error?: {
    code: number,
    message: string,
    data?: unknown
  }
}
```

LANGUAGE: typescript
CODE:
```
{
  jsonrpc: "2.0",
  method: string,
  params?: object
}
```

----------------------------------------

TITLE: Response for Calling an MCP Tool (JSON)
DESCRIPTION: JSON structure for the `tools/call` response in the Model Context Protocol, returning the result of a tool invocation. The result can contain structured or unstructured content and indicates if an error occurred. Includes a sample text content result.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/specification/draft/server/tools.mdx#_snippet_4

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Current weather in New York:\nTemperature: 72°F\nConditions: Partly cloudy"
      }
    ],
    "isError": false
  }
}
```

----------------------------------------

TITLE: MCP Request Interface
DESCRIPTION: TypeScript interface defining the structure of request messages in MCP, which expect a response from the other side.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/docs/concepts/architecture.mdx#2025-04-23_snippet_3

LANGUAGE: typescript
CODE:
```
interface Request {
  method: string;
  params?: { ... };
}
```

----------------------------------------

TITLE: Request for Calling an MCP Tool (JSON)
DESCRIPTION: JSON structure for the `tools/call` request in the Model Context Protocol, used by clients to invoke a specific tool by name with provided arguments matching its input schema.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/specification/draft/server/tools.mdx#_snippet_3

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tools/call",
  "params": {
    "name": "get_weather",
    "arguments": {
      "location": "New York"
    }
  }
}
```

----------------------------------------

TITLE: Initializing MCP Client Structure (TypeScript)
DESCRIPTION: Sets up necessary imports for Anthropic SDK, MCP SDK, readline, and dotenv. It loads the `ANTHROPIC_API_KEY` from environment variables and throws an error if not found. The `MCPClient` class is defined with private properties for the MCP client, Anthropic client, transport, and tools, initializing the Anthropic and MCP clients in the constructor.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/quickstart/client.mdx#_snippet_17

LANGUAGE: typescript
CODE:
```
import { Anthropic } from "@anthropic-ai/sdk";
import {
  MessageParam,
  Tool,
} from "@anthropic-ai/sdk/resources/messages/messages.mjs";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";
import readline from "readline/promises";
import dotenv from "dotenv";

dotenv.config();

const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY;
if (!ANTHROPIC_API_KEY) {
  throw new Error("ANTHROPIC_API_KEY is not set");
}

class MCPClient {
  private mcp: Client;
  private anthropic: Anthropic;
  private transport: StdioClientTransport | null = null;
  private tools: Tool[] = [];

  constructor() {
    this.anthropic = new Anthropic({
      apiKey: ANTHROPIC_API_KEY,
    });
    this.mcp = new Client({ name: "mcp-client-cli", version: "1.0.0" });
  }
  // methods will go here
}
```

----------------------------------------

TITLE: Requesting LLM Generation in MCP (JSON)
DESCRIPTION: Example of a sampling/createMessage request in the Model Context Protocol, including messages, model preferences, and system prompt.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/specification/2025-03-26/client/sampling.mdx#2025-04-23_snippet_1

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "sampling/createMessage",
  "params": {
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "What is the capital of France?"
        }
      }
    ],
    "modelPreferences": {
      "hints": [
        {
          "name": "claude-3-sonnet"
        }
      ],
      "intelligencePriority": 0.8,
      "speedPriority": 0.5
    },
    "systemPrompt": "You are a helpful assistant.",
    "maxTokens": 100
  }
}
```

----------------------------------------

TITLE: MCP Server Implementation in TypeScript
DESCRIPTION: Example implementation of an MCP server in TypeScript, demonstrating server initialization, request handling, and transport connection using stdio.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/docs/concepts/architecture.mdx#2025-04-23_snippet_9

LANGUAGE: typescript
CODE:
```
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

const server = new Server({
  name: "example-server",
  version: "1.0.0"
}, {
  capabilities: {
    resources: {}
  }
});

// Handle requests
server.setRequestHandler(ListResourcesRequestSchema, async () => {
  return {
    resources: [
      {
        uri: "example://resource",
        name: "Example Resource"
      }
    ]
  };
});

// Connect transport
const transport = new StdioServerTransport();
await server.connect(transport);
```

----------------------------------------

TITLE: Implementing Multi-step Workflows in TypeScript
DESCRIPTION: Shows how to implement a multi-step workflow for debugging errors, demonstrating the use of asynchronous functions and multiple message exchanges.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/docs/concepts/prompts.mdx#2025-04-23_snippet_5

LANGUAGE: typescript
CODE:
```
const debugWorkflow = {
  name: "debug-error",
  async getMessages(error: string) {
    return [
      {
        role: "user",
        content: {
          type: "text",
          text: `Here's an error I'm seeing: ${error}`
        }
      },
      {
        role: "assistant",
        content: {
          type: "text",
          text: "I'll help analyze this error. What have you tried so far?"
        }
      },
      {
        role: "user",
        content: {
          type: "text",
          text: "I've tried restarting the service, but the error persists."
        }
      }
    ];
  }
};
```

----------------------------------------

TITLE: Visualizing OAuth 2.1 Authorization Code Flow with PKCE for MCP
DESCRIPTION: Sequence diagram showing the OAuth 2.1 authorization code flow with PKCE for public clients in MCP. It illustrates the interaction between the User-Agent (Browser), MCP Client, and MCP Server during the authorization process.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/specification/2025-03-26/basic/authorization.mdx#2025-04-23_snippet_0

LANGUAGE: mermaid
CODE:
```
sequenceDiagram
    participant B as User-Agent (Browser)
    participant C as Client
    participant M as MCP Server

    C->>M: MCP Request
    M->>C: HTTP 401 Unauthorized
    Note over C: Generate code_verifier and code_challenge
    C->>B: Open browser with authorization URL + code_challenge
    B->>M: GET /authorize
    Note over M: User logs in and authorizes
    M->>B: Redirect to callback URL with auth code
    B->>C: Callback with authorization code
    C->>M: Token Request with code + code_verifier
    M->>C: Access Token (+ Refresh Token)
    C->>M: MCP Request with Access Token
    Note over C,M: Begin standard MCP message exchange
```

----------------------------------------

TITLE: Defining Main Entry Point (Kotlin)
DESCRIPTION: Defines the main function for the client application. It requires a command-line argument specifying the path to the server script, initializes and connects an `MCPClient` instance, and then starts the interactive `chatLoop`. It uses `runBlocking` to execute the suspend functions.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/quickstart/client.mdx#_snippet_50

LANGUAGE: kotlin
CODE:
```
fun main(args: Array<String>) = runBlocking {
    if (args.isEmpty()) throw IllegalArgumentException("Usage: java -jar <your_path>/build/libs/kotlin-mcp-client-0.1.0-all.jar <path_to_server_script>")
    val serverPath = args.first()
    val client = MCPClient()
    client.use {
        client.connectToServer(serverPath)
        client.chatLoop()
    }
}
```

----------------------------------------

TITLE: Tool Interaction Sequence Diagram in Mermaid
DESCRIPTION: Mermaid sequence diagram illustrating the message flow between LLM, Client, and Server for tool discovery, selection, invocation, and updates.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/specification/2025-03-26/server/tools.mdx#2025-04-23_snippet_6

LANGUAGE: mermaid
CODE:
```
sequenceDiagram
    participant LLM
    participant Client
    participant Server

    Note over Client,Server: Discovery
    Client->>Server: tools/list
    Server-->>Client: List of tools

    Note over Client,LLM: Tool Selection
    LLM->>Client: Select tool to use

    Note over Client,Server: Invocation
    Client->>Server: tools/call
    Server-->>Client: Tool result
    Client->>LLM: Process result

    Note over Client,Server: Updates
    Server--)Client: tools/list_changed
    Client->>Server: tools/list
    Server-->>Client: Updated tools
```

----------------------------------------

TITLE: Using Prompt System with MCP Java Client (Async API)
DESCRIPTION: Demonstrates interaction with server-side prompt templates using the asynchronous API of the MCP Java client. It shows asynchronous listing of available prompt templates and asynchronous execution of a prompt template with custom parameters.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/sdk/java/mcp-client.mdx#2025-04-23_snippet_14

LANGUAGE: java
CODE:
```
// List available prompt templates asynchronously
client.listPrompts()
    .doOnNext(prompts -> prompts.forEach(prompt -> 
        System.out.println(prompt.getName())))
    .subscribe();

// Execute a prompt template asynchronously
client.executePrompt("echo", Map.of(
        "text", "Hello, World!"
    ))
    .subscribe();
```

----------------------------------------

TITLE: Using Tools with Synchronous MCP Client in Java
DESCRIPTION: Demonstrates how to discover and execute server-side tools using the synchronous MCP client API. This example shows listing available tools and executing a calculator tool with specific parameters.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/sdk/java/mcp-client.mdx#2025-04-23_snippet_9

LANGUAGE: java
CODE:
```
// List available tools and their names
var tools = client.listTools();
tools.forEach(tool -> System.out.println(tool.getName()));

// Execute a tool with parameters
var result = client.callTool("calculator", Map.of(
    "operation", "add",
    "a", 1,
    "b", 2
));
```

----------------------------------------

TITLE: MCP Server Implementation in Python
DESCRIPTION: Example implementation of an MCP server in Python, demonstrating server creation, resource listing functionality, and running the server with stdio transport.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/docs/concepts/architecture.mdx#2025-04-23_snippet_10

LANGUAGE: python
CODE:
```
import asyncio
import mcp.types as types
from mcp.server import Server
from mcp.server.stdio import stdio_server

app = Server("example-server")

@app.list_resources()
async def list_resources() -> list[types.Resource]:
    return [
        types.Resource(
            uri="example://resource",
            name="Example Resource"
        )
    ]

async def main():
    async with stdio_server() as streams:
        await app.run(
            streams[0],
            streams[1],
            app.create_initialization_options()
        )

if __name__ == "__main__":
    asyncio.run(main())
```

----------------------------------------

TITLE: Sending Initialized Notification in MCP
DESCRIPTION: JSON-RPC notification sent by the client to indicate it is ready to begin normal operations after successful initialization. This must be sent before any other requests or notifications.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/specification/2025-03-26/basic/lifecycle.mdx#2025-04-23_snippet_3

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/initialized"
}
```

----------------------------------------

TITLE: Configure Claude with MCP Servers (JSON)
DESCRIPTION: Configure the Claude agent to use multiple Model Context Protocol (MCP) servers by defining their commands, arguments, and environment variables in a JSON structure. This allows Claude to interact with external services via MCP.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/examples.mdx#_snippet_3

LANGUAGE: JSON
CODE:
```
{
  "mcpServers": {
    "memory": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-memory"]
    },
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/path/to/allowed/files"]
    },
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "<YOUR_TOKEN>"
      }
    }
  }
}
```

----------------------------------------

TITLE: Configuring Sampling Support for MCP Client in Java
DESCRIPTION: Demonstrates how to configure LLM sampling support for an MCP client, allowing servers to request language model interactions through the client. The sampling handler enables controlled AI model access without sharing API keys.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/sdk/java/mcp-client.mdx#2025-04-23_snippet_7

LANGUAGE: java
CODE:
```
// Configure sampling handler
Function<CreateMessageRequest, CreateMessageResult> samplingHandler = request -> {
    // Sampling implementation that interfaces with LLM
    return new CreateMessageResult(response);
};

// Create client with sampling support
var client = McpClient.sync(transport)
    .capabilities(ClientCapabilities.builder()
        .sampling()
        .build())
    .sampling(samplingHandler)
    .build();
```

----------------------------------------

TITLE: Defining JSON-RPC Notification Message Structure in TypeScript
DESCRIPTION: TypeScript interface for JSON-RPC 2.0 notification messages. Notifications are one-way messages that must include a method name and optional parameters, but no ID.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/specification/2025-03-26/basic/index.mdx#2025-04-23_snippet_2

LANGUAGE: typescript
CODE:
```
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

----------------------------------------

TITLE: Implementing MCP Resource Support in TypeScript
DESCRIPTION: A complete example showing how to implement resource support in an MCP server using TypeScript. Includes server initialization with resource capabilities, list handler, and read handler.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/docs/concepts/resources.mdx#2025-04-23_snippet_4

LANGUAGE: typescript
CODE:
```
const server = new Server({
  name: "example-server",
  version: "1.0.0"
}, {
  capabilities: {
    resources: {}
  }
});

// List available resources
server.setRequestHandler(ListResourcesRequestSchema, async () => {
  return {
    resources: [
      {
        uri: "file:///logs/app.log",
        name: "Application Logs",
        mimeType: "text/plain"
      }
    ]
  };
});

// Read resource contents
server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
  const uri = request.params.uri;

  if (uri === "file:///logs/app.log") {
    const logContents = await readLogFile();
    return {
      contents: [
        {
          uri,
          mimeType: "text/plain",
          text: logContents
        }
      ]
    };
  }

  throw new Error("Resource not found");
});
```

----------------------------------------

TITLE: Stdio Transport Implementation
DESCRIPTION: Implementation examples for stdio transport in both client and server configurations using TypeScript and Python.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/docs/concepts/transports.mdx#2025-04-23_snippet_1

LANGUAGE: typescript
CODE:
```
const server = new Server({
  name: "example-server",
  version: "1.0.0"
}, {
  capabilities: {}
});

const transport = new StdioServerTransport();
await server.connect(transport);
```

LANGUAGE: typescript
CODE:
```
const client = new Client({
  name: "example-client",
  version: "1.0.0"
}, {
  capabilities: {}
});

const transport = new StdioClientTransport({
  command: "./server",
  args: ["--option", "value"]
});
await client.connect(transport);
```

LANGUAGE: python
CODE:
```
app = Server("example-server")

async with stdio_server() as streams:
    await app.run(
        streams[0],
        streams[1],
        app.create_initialization_options()
    )
```

LANGUAGE: python
CODE:
```
params = StdioServerParameters(
    command="./server",
    args=["--option", "value"]
)

async with stdio_client(params) as streams:
    async with ClientSession(streams[0], streams[1]) as session:
        await session.initialize()
```

----------------------------------------

TITLE: Implementing Tools in Python MCP Server
DESCRIPTION: This code shows how to implement a basic tool (calculate_sum) in a Python MCP server, including tool definition and execution handling.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/docs/concepts/tools.mdx#2025-04-23_snippet_2

LANGUAGE: python
CODE:
```
app = Server("example-server")

@app.list_tools()
async def list_tools() -> list[types.Tool]:
    return [
        types.Tool(
            name="calculate_sum",
            description="Add two numbers together",
            inputSchema={
                "type": "object",
                "properties": {
                    "a": {"type": "number"},
                    "b": {"type": "number"}
                },
                "required": ["a", "b"]
            }
        )
    ]

@app.call_tool()
async def call_tool(
    name: str,
    arguments: dict
) -> list[types.TextContent | types.ImageContent | types.EmbeddedResource]:
    if name == "calculate_sum":
        a = arguments["a"]
        b = arguments["b"]
        result = a + b
        return [types.TextContent(type="text", text=str(result))]
    raise ValueError(f"Tool not found: {name}")
```

----------------------------------------

TITLE: Responding to Initialize Request in MCP
DESCRIPTION: JSON-RPC response from the server to the initialize request. It includes the protocol version, server capabilities, server information, and optional instructions for the client.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/specification/2025-03-26/basic/lifecycle.mdx#2025-04-23_snippet_2

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": "2024-11-05",
    "capabilities": {
      "logging": {},
      "prompts": {
        "listChanged": true
      },
      "resources": {
        "subscribe": true,
        "listChanged": true
      },
      "tools": {
        "listChanged": true
      }
    },
    "serverInfo": {
      "name": "ExampleServer",
      "version": "1.0.0"
    },
    "instructions": "Optional instructions for the client"
  }
}
```

----------------------------------------

TITLE: MCP Error Interface
DESCRIPTION: TypeScript interface defining the structure of error responses in MCP, indicating that a request failed.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/docs/concepts/architecture.mdx#2025-04-23_snippet_5

LANGUAGE: typescript
CODE:
```
interface Error {
  code: number;
  message: string;
  data?: unknown;
}
```

----------------------------------------

TITLE: MCP Capability Negotiation Sequence Diagram
DESCRIPTION: Mermaid sequence diagram demonstrating the flow of capability negotiation between host, client, and server, including session initialization, request handling, and notification flow.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/specification/2024-11-05/architecture/index.mdx#2025-04-23_snippet_1

LANGUAGE: mermaid
CODE:
```
sequenceDiagram
    participant Host
    participant Client
    participant Server

    Host->>+Client: Initialize client
    Client->>+Server: Initialize session with capabilities
    Server-->>Client: Respond with supported capabilities

    Note over Host,Server: Active Session with Negotiated Features

    loop Client Requests
        Host->>Client: User- or model-initiated action
        Client->>Server: Request (tools/resources)
        Server-->>Client: Response
        Client-->>Host: Update UI or respond to model
    end

    loop Server Requests
        Server->>Client: Request (sampling)
        Client->>Host: Forward to AI
        Host-->>Client: AI response
        Client-->>Server: Response
    end

    loop Notifications
        Server--)Client: Resource updates
        Client--)Server: Status changes
    end

    Host->>Client: Terminate
    Client->>-Server: End session
    deactivate Server
```

----------------------------------------

TITLE: Initializing MCP Client and Listing Tools - C#
DESCRIPTION: Parses command line arguments to determine the server command and arguments using a helper function. It sets up an StdioClientTransport for communication, creates the MCP client asynchronously using a factory, connects to the specified server, and then iterates through and prints the names of the available tools reported by the server.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/quickstart/client.mdx#_snippet_57

LANGUAGE: csharp
CODE:
```
var (command, arguments) = GetCommandAndArguments(args);

var clientTransport = new StdioClientTransport(new()
{
    Name = "Demo Server",
    Command = command,
    Arguments = arguments,
});

await using var mcpClient = await McpClientFactory.CreateAsync(clientTransport);

var tools = await mcpClient.ListToolsAsync();
foreach (var tool in tools)
{
    Console.WriteLine($"Connected to server with tools: {tool.Name}");
}
```

----------------------------------------

TITLE: Server Connection Implementation
DESCRIPTION: Method for establishing connection with an MCP server and listing available tools.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/tutorials/building-a-client-node.mdx#2025-04-23_snippet_5

LANGUAGE: typescript
CODE:
```
  async connectToServer(serverScriptPath: string): Promise<void> {
    const isPython = serverScriptPath.endsWith(".py");
    const isJs = serverScriptPath.endsWith(".js");

    if (!isPython && !isJs) {
      throw new Error("Server script must be a .py or .js file");
    }

    const command = isPython ? "python" : "node";

    this.transport = new StdioClientTransport({
      command,
      args: [serverScriptPath],
    });

    this.client = new Client(
      {
        name: "mcp-client",
        version: "1.0.0",
      },
      {
        capabilities: {},
      }
    );

    await this.client.connect(this.transport);

    // List available tools
    const response = await this.client.request(
      { method: "tools/list" },
      ListToolsResultSchema
    );

    console.log(
      "\nConnected to server with tools:",
      response.tools.map((tool: any) => tool.name)
    );
  }
```

----------------------------------------

TITLE: Creating and Using Synchronous MCP Client in Java
DESCRIPTION: Demonstrates how to create, configure, and use a synchronous MCP client with custom capabilities. The example shows initializing a connection, listing and calling tools, managing resources and prompts, and working with roots functionality.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/sdk/java/mcp-client.mdx#2025-04-23_snippet_0

LANGUAGE: java
CODE:
```
// Create a sync client with custom configuration
McpSyncClient client = McpClient.sync(transport)
    .requestTimeout(Duration.ofSeconds(10))
    .capabilities(ClientCapabilities.builder()
        .roots(true)      // Enable roots capability
        .sampling()       // Enable sampling capability
        .build())
    .sampling(request -> new CreateMessageResult(response))
    .build();

// Initialize connection
client.initialize();

// List available tools
ListToolsResult tools = client.listTools();

// Call a tool
CallToolResult result = client.callTool(
    new CallToolRequest("calculator", 
        Map.of("operation", "add", "a", 2, "b", 3))
);

// List and read resources
ListResourcesResult resources = client.listResources();
ReadResourceResult resource = client.readResource(
    new ReadResourceRequest("resource://uri")
);

// List and use prompts
ListPromptsResult prompts = client.listPrompts();
GetPromptResult prompt = client.getPrompt(
    new GetPromptRequest("greeting", Map.of("name", "Spring"))
);

// Add/remove roots
client.addRoot(new Root("file:///path", "description"));
client.removeRoot("file:///path");

// Close client
client.closeGracefully();
```

----------------------------------------

TITLE: Tool Call Request and Response
DESCRIPTION: JSON-RPC messages for invoking a tool and receiving its result, demonstrating parameter passing and response handling.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/specification/2024-11-05/server/tools.mdx#2025-04-23_snippet_2

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tools/call",
  "params": {
    "name": "get_weather",
    "arguments": {
      "location": "New York"
    }
  }
}
```

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Current weather in New York:\nTemperature: 72°F\nConditions: Partly cloudy"
      }
    ],
    "isError": false
  }
}
```

----------------------------------------

TITLE: Implementing Interactive Chat Loop and Cleanup (TypeScript)
DESCRIPTION: The `chatLoop` method creates a readline interface for interactive input/output. It prompts the user for queries, processes them using `processQuery`, and prints the response. The loop continues until the user types 'quit'. The `cleanup` method closes the MCP client connection, ensuring resources are properly released.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/quickstart/client.mdx#_snippet_20

LANGUAGE: typescript
CODE:
```
async chatLoop() {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  try {
    console.log("\nMCP Client Started!");
    console.log("Type your queries or 'quit' to exit.");

    while (true) {
      const message = await rl.question("\nQuery: ");
      if (message.toLowerCase() === "quit") {
        break;
      }
      const response = await this.processQuery(message);
      console.log("\n" + response);
    }
  } finally {
    rl.close();
  }
}

async cleanup() {
  await this.mcp.close();
}
```

----------------------------------------

TITLE: Configuring MCP Server Capabilities in Java
DESCRIPTION: This snippet demonstrates how to configure various capabilities for an MCP server, including resource support, tool support, prompt support, and logging.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/sdk/java/mcp-server.mdx#2025-04-23_snippet_6

LANGUAGE: java
CODE:
```
var capabilities = ServerCapabilities.builder()
    .resources(false, true)  // Resource support with list changes notifications
    .tools(true)            // Tool support with list changes notifications
    .prompts(true)          // Prompt support with list changes notifications
    .logging()              // Enable logging support (enabled by default with logging level INFO)
    .build();
```

----------------------------------------

TITLE: Implementing MCP Tools for Weather Alerts and Forecast in Python
DESCRIPTION: Python implementation of MCP tools for fetching weather alerts and forecasts using the National Weather Service API.
SOURCE: https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/docs/quickstart/server.mdx#2025-04-23_snippet_6

LANGUAGE: python
CODE:
```
@mcp.tool()
async def get_alerts(state: str) -> str:
    """Get weather alerts for a US state.

    Args:
        state: Two-letter US state code (e.g. CA, NY)
    """
    url = f"{NWS_API_BASE}/alerts/active/area/{state}"
    data = await make_nws_request(url)

    if not data or "features" not in data:
        return "Unable to fetch alerts or no alerts found."

    if not data["features"]:
        return "No active alerts for this state."

    alerts = [format_alert(feature) for feature in data["features"]]
    return "\n---\n".join(alerts)

@mcp.tool()
async def get_forecast(latitude: float, longitude: float) -> str:
    """Get weather forecast for a location.

    Args:
        latitude: Latitude of the location
        longitude: Longitude of the location
    """
    # First get the forecast grid endpoint
    points_url = f"{NWS_API_BASE}/points/{latitude},{longitude}"
    points_data = await make_nws_request(points_url)

    if not points_data:
        return "Unable to fetch forecast data for this location."

    # Get the forecast URL from the points response
    forecast_url = points_data["properties"]["forecast"]
    forecast_data = await make_nws_request(forecast_url)

    if not forecast_data:
        return "Unable to fetch detailed forecast."

    # Format the periods into a readable forecast
    periods = forecast_data["properties"]["periods"]
    forecasts = []
    for period in periods[:5]:  # Only show next 5 periods
        forecast = f"""
{period['name']}:
Temperature: {period['temperature']}°{period['temperatureUnit']}
Wind: {period['windSpeed']} {period['windDirection']}
Forecast: {period['detailedForecast']}
"""
        forecasts.append(forecast)

    return "\n---\n".join(forecasts)
```